<!--
Workflow Automation System Frontend

This is the main frontend interface for the AI-powered workflow automation system.
It provides a comprehensive web UI for:

1. Workflow Creation:
   - Natural language workflow descriptions
   - AI-powered code generation using Anthropic Claude
   - Real-time status updates and code preview

2. File Management:
   - Drag-and-drop file uploads
   - File attachment to workflow queries
   - Integration with LightOn Paradigm API for document processing

3. Workflow Execution:
   - Execute workflows with user queries
   - Support for attached documents
   - Real-time execution monitoring with detailed logs

4. Monitoring and Debugging:
   - Comprehensive API call logging
   - Step-by-step workflow execution tracking
   - Error handling and user feedback

Key Features:
- Cross-domain API integration with CORS support
- Real-time logging with color-coded output
- Responsive design with modern CSS styling
- File drag-and-drop with visual feedback

Architecture:
- Pure vanilla JavaScript (no frameworks)
- REST API integration with fetch()
- Modular function design for maintainability
- Comprehensive error handling and user feedback
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workflow Automation Test</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ö°</text></svg>">
    <style>
        /* 
         * CSS Styles for Workflow Automation Interface
         * 
         * Provides a clean, modern interface with:
         * - Responsive design for desktop and mobile
         * - Color-coded status indicators
         * - Terminal-style logging interface
         * - Drag-and-drop file upload styling
         * - Button states and hover effects
         */
        
        /* Base layout and typography */
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1, h2 {
            color: #333;
        }
        textarea, input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        button {
            background: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .result {
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .error {
            background: #ffe6e6;
            border-color: #ff9999;
            color: #cc0000;
        }
        .success {
            background: #e6ffe6;
            border-color: #99ff99;
            color: #006600;
        }
        .loading {
            color: #666;
            font-style: italic;
        }
        .workflow-info {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .logs-container {
            background: #1e1e1e;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 15px;
            border-radius: 4px;
            max-height: 600px;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.4;
        }
        .log-entry {
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .log-timestamp {
            color: #888;
        }
        .log-api-call {
            color: #00ccff;
            font-weight: bold;
        }
        .log-query {
            color: #ffcc00;
        }
        .log-doc-ids {
            color: #ff9900;
        }
        .log-response {
            color: #00ff88;
        }
        .log-error {
            color: #ff4444;
        }
        .log-workflow-step {
            color: #ff00ff;
            font-weight: bold;
        }
        .log-endpoint {
            color: #00ffff;
        }
        .log-payload {
            color: #ffaa00;
        }
        .log-chunk {
            color: #aaffaa;
            font-size: 10px;
        }
        .log-detailed {
            color: #cccccc;
            font-size: 10px;
            margin-left: 15px;
        }
        .clear-logs {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 11px;
            margin-bottom: 10px;
        }
        .file-upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: #fafafa;
            margin: 10px 0;
        }
        .file-upload-area.dragover {
            border-color: #007bff;
            background: #e7f3ff;
        }
        .file-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        .file-list li {
            background: #f8f9fa;
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 4px;
            border-left: 4px solid #28a745;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .file-info {
            flex-grow: 1;
        }
        .file-actions {
            display: flex;
            gap: 8px;
        }
        .file-actions button {
            padding: 4px 8px;
            font-size: 12px;
            margin: 0;
        }
        .remove-file {
            background: #dc3545;
        }
        .remove-file:hover {
            background: #c82333;
        }
        /* Add these styles to your existing CSS section */
        h1 {
            font-size: 32px; /* Increased to match the logo text size better */
            font-weight: 700; /* Increased to bold to match the logo */
            color: #000;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; /* More comprehensive font stack */
            letter-spacing: -0.5px; /* Tighter letter spacing to match logo */
            line-height: 1; /* Tighter line height */
        }

        h1 img {
            height: 52px;
            width: auto;
            margin-right: 10px;
            margin-top: 3px;
            vertical-align: middle;
        }

        h1 span {
            margin-top: 2px;
            font-weight: 700; /* Ensure the span also has the same weight */
            font-size: 32px; /* Ensure the span also has the same size */
        }
        .container h3 {
            color: #333;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .container .helper-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
        }

        .container .helper-section h3 {
            color: #666;
            font-size: 16px;
            margin-bottom: 15px;
        }

        .container .helper-section p {
            color: #666;
            font-size: 14px;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <h1>
        <img src="./lighton-logo.png" alt="LightOn Logo">
        <span>workflow builder</span>
    </h1>
    
    <!-- Step 1: Create Workflow -->
    <div class="container">
        <h2>1. Create Workflow</h2>
        <p>Describe a workflow using natural language:</p>
        <textarea id="workflowDescription" placeholder="Example: Search for documents about LightOn, then analyze those documents to summarize key information...">Search for documents about the user's question, then analyze those documents to provide a detailed summary.</textarea>
        <input type="text" id="workflowName" placeholder="Workflow name (optional)" />
        <button onclick="createWorkflow()">Create Workflow</button>
        <div id="workflowResult"></div>
    </div>

    <!-- Step 2: Test Workflow -->
    <div class="container">
        <h2>2. Test Workflow</h2>
        <p>Enter your query and optionally attach documents:</p>
        
        <!-- Query Input -->
        <input type="text" id="testQuery" placeholder="What is LightOn's main technology platform?" />
        
        <!-- Document Upload Section -->
        <div style="margin: 15px 0;">
            <label style="display: block; margin-bottom: 8px; font-weight: bold;">üìé Attach Documents (Optional):</label>
            <div class="file-upload-area" id="queryUploadArea" ondrop="handleQueryDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                <p>üìé Drag and drop files here or <button onclick="document.getElementById('queryFileInput').click()">browse files</button></p>
                <input type="file" id="queryFileInput" multiple style="display: none;" onchange="handleQueryFileSelect(event)">
                <p style="font-size: 12px; color: #666;">Upload documents to analyze with your query</p>
            </div>
            
            <div id="queryUploadStatus"></div>
            <ul class="file-list" id="queryFilesList"></ul>
        </div>
        
        <button onclick="executeWorkflowWithQuery()" id="testButton" disabled>Test Workflow</button>
        <div id="testResult"></div>
    </div>

    <!-- Step 3: Update Workflow -->
    <div class="container">
        <h2>3. Update your workflow until it works</h2>
        <p>Edit the workflow description above and regenerate the workflow to refine its behavior. You can modify the natural language description to add new steps, change the logic, or improve the workflow based on your test results.</p>
        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 10px 0;">
            <strong>üí° Tip:</strong> After testing, go back to step 1, update your workflow description, and click "Create Workflow" again to generate an improved version.
        </div>
        
        <!-- Monitoring Helper Section -->
        <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
            <h3 style="color: #666; font-size: 16px; margin-bottom: 15px;">üìä Monitor Workflow Execution</h3>
            <p style="color: #666; font-size: 14px; margin-bottom: 15px;">Monitor every step of workflow execution with detailed information:</p>
            <ul style="font-size: 12px; color: #666; margin: 10px 0;">
                <li>üîç API endpoints called and payloads sent</li>
                <li>üìä Document IDs, file IDs, and search queries</li>
                <li>üí¨ Response content and analysis results</li>
                <li>üìÑ Document chunks and file processing details</li>
                <li>‚ö° Step-by-step workflow execution flow</li>
                <li>‚ùå Error handling and fallback mechanisms</li>
            </ul>
            <button onclick="clearLogs()" class="clear-logs">Clear Logs</button>
            <div class="logs-container" id="logsContainer">
                <div class="log-entry">
                    <span class="log-timestamp">[Ready]</span> <span class="log-response">Waiting for API activity...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Step 5: Add to Paradigm -->
    <div class="container">
        <h2>5. Add your workflow to Paradigm</h2>
        <p>Paradigm has a feature called "Third Party Tools" that allows you to create custom tools within the Paradigm UI. When you use the tool, it will execute your deployed workflow.</p>
        
        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 10px 0;">
            <h3>Step-by-step instructions:</h3>
            <ol style="margin-left: 20px;">
                <li><strong>Access Third Party Tools:</strong> In your Paradigm admin interface, navigate to the Third Party Tools section</li>
                <li><strong>Create New Tool:</strong> Click "Add Third Party Tool"</li>
                <li><strong>Fill in Basic Information:</strong>
                    <ul style="margin-left: 20px;">
                        <li><strong>Name:</strong> Give your workflow a descriptive name (e.g., "Document Analysis Workflow")</li>
                        <li><strong>Enabled:</strong> Check this box to activate the tool</li>
                        <li><strong>Description:</strong> Provide a detailed description of what your workflow does. Be specific about:
                            <ul style="margin-left: 20px;">
                                <li>What tasks it can perform</li>
                                <li>What types of queries it handles</li>
                                <li>Any limitations or requirements</li>
                                <li>Example use cases</li>
                            </ul>
                            <strong>Example:</strong> "This workflow analyzes documents and provides detailed summaries. It can search through uploaded documents, extract key information, and generate comprehensive analysis reports. Works best with text-based documents and specific questions about document content."
                        </li>
                    </ul>
                </li>
                <li><strong>HTTP Configuration:</strong>
                    <ul style="margin-left: 20px;">
                        <li><strong>HTTP Method:</strong> Select "POST" (since your workflow expects POST requests)</li>
                        <li><strong>Headers:</strong> Add any required headers (usually none needed for basic setup)</li>
                        <li><strong>Require Document:</strong> Set to "Yes" if your workflow needs documents, "No" if it works with just queries</li>
                    </ul>
                </li>
                <li><strong>Creation Method:</strong> Select "Parameters/URL"</li>
                <li><strong>URL:</strong> Enter your deployed API endpoint URL:
                    <ul style="margin-left: 20px;">
                        <li>For Vercel: <code>https://your-project.vercel.app/api/workflow</code></li>
                        <li>For custom infrastructure: <code>http://your-server:8000/workflow</code></li>
                    </ul>
                </li>
                <li><strong>Parameters:</strong> Configure the parameters your API expects:
                    <ul style="margin-left: 20px;">
                        <li><strong>Body Parameters:</strong> Add a parameter named "query" of type "string"</li>
                        <li>If your API expects additional parameters, add them as needed</li>
                    </ul>
                </li>
                <li><strong>Save and Deploy:</strong> Save your tool configuration, then navigate to Chat settings in the Paradigm admin and activate your third party tool using the arrow.</li>
            </ol>
            
            <div style="background: #e3f2fd; padding: 10px; border-radius: 4px; margin-top: 15px;">
                <strong>ÔøΩÔøΩ Important:</strong> The description you provide is crucial for tool routing. Paradigm uses this description to understand when to use your tool, so make it as detailed and accurate as possible.
            </div>
        </div>
    </div>

    <!-- Step 6: Test and Share -->
    <div class="container">
        <h2>6. üöÄ Test and share</h2>
        <p>You are now set up to use your workflow as a third party tool within Paradigm. The other users in your company can also access this tool, so spread the news and show them how it works!</p>
    </div>

    <script>
        /*
         * Workflow Automation Frontend JavaScript
         * 
         * This script provides the complete frontend functionality for the workflow
         * automation system, including:
         * 
         * 1. API Integration:
         *    - RESTful API calls to backend services
         *    - Error handling and response processing
         *    - Cross-domain request handling
         * 
         * 2. File Management:
         *    - Drag-and-drop file uploads
         *    - File attachment to queries
         *    - File deletion and management
         * 
         * 3. Logging System:
         *    - Real-time API call logging
         *    - Color-coded log entries by type
         *    - Detailed workflow execution tracking
         * 
         * 4. User Interface:
         *    - Dynamic UI updates based on state
         *    - Form validation and user feedback
         *    - Responsive design interactions
         * 
         * Architecture:
         * - Event-driven programming model
         * - Modular functions for maintainability
         * - Global state management for workflow tracking
         * - Comprehensive error handling throughout
         */
        
        // Global configuration and state variables
        const API_BASE = 'http://localhost:8000'  // Local backend API base URL
        // const API_BASE = '/api'  // Same-domain API base URL for Vercel deployment
        let currentWorkflowId = null;    // Currently active workflow ID
        let logCounter = 0;              // Counter for log entry IDs
        let queryAttachedFiles = [];     // Files attached to current query

        // =============================================================
        // FILE UPLOAD AND MANAGEMENT FUNCTIONS
        // =============================================================
        
        /**
         * Handle drag-and-drop file uploads for query attachments.
         * Prevents default drag behavior and processes dropped files.
         */
        function handleQueryDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const uploadArea = document.getElementById('queryUploadArea');
            uploadArea.classList.remove('dragover');
            
            const files = Array.from(event.dataTransfer.files);
            uploadQueryFiles(files);
        }

        /**
         * Handle drag-over events for file upload areas.
         * Provides visual feedback during drag operations.
         */
        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const uploadArea = event.target.closest('.file-upload-area');
            if (uploadArea) {
                uploadArea.classList.add('dragover');
            }
        }

        /**
         * Handle drag-leave events for file upload areas.
         * Removes visual feedback when drag leaves the area.
         */
        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const uploadArea = event.target.closest('.file-upload-area');
            if (uploadArea) {
                uploadArea.classList.remove('dragover');
            }
        }

        /**
         * Handle file selection from file input element.
         * Processes files selected via browse button.
         */
        function handleQueryFileSelect(event) {
            const files = Array.from(event.target.files);
            uploadQueryFiles(files);
        }

        /**
         * Upload files to the backend and attach them to queries.
         * Handles multiple files, updates UI, and manages error states.
         * 
         * @param {FileList} files - Files to upload
         */
        async function uploadQueryFiles(files) {
            const statusDiv = document.getElementById('queryUploadStatus');
            const filesList = document.getElementById('queryFilesList');
            
            for (const file of files) {
                try {
                    statusDiv.innerHTML = `<div class="result loading">Uploading ${file.name}...</div>`;
                    addLog(`üì§ Uploading query attachment: ${file.name} (${file.size} bytes)`, 'info');
                    
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('collection_type', 'private');
                    
                    const { response, data } = await loggedFetch(`${API_BASE}/files/upload`, {
                        method: 'POST',
                        body: formData
                    }, `UPLOAD QUERY FILE: ${file.name}`);
                    
                    if (response.ok) {
                        // Add to query attached files list
                        queryAttachedFiles.push(data);
                        
                        // Update UI
                        const listItem = document.createElement('li');
                        listItem.innerHTML = `
                            <div class="file-info">
                                <strong>${data.filename}</strong> (ID: ${data.id})
                                <br><small>${data.bytes} bytes ‚Ä¢ Status: ${data.status}</small>
                            </div>
                            <div class="file-actions">
                                <button onclick="removeQueryFile(${data.id})" class="remove-file" title="Remove attachment">üóëÔ∏è</button>
                            </div>
                        `;
                        filesList.appendChild(listItem);
                        
                        statusDiv.innerHTML = `<div class="result success">‚úÖ ${file.name} attached to query!</div>`;
                        addLog(`‚úÖ Query file uploaded successfully: ID ${data.id}`, 'response');
                        
                    } else {
                        statusDiv.innerHTML = `<div class="result error">‚ùå Failed to upload ${file.name}</div>`;
                        addLog(`‚ùå Query upload failed: ${data.detail || 'Unknown error'}`, 'error');
                    }
                    
                } catch (error) {
                    statusDiv.innerHTML = `<div class="result error">‚ùå Network error uploading ${file.name}</div>`;
                    addLog(`‚ùå Query upload network error: ${error.message}`, 'error');
                }
            }
            
            // Clear file input
            document.getElementById('queryFileInput').value = '';
        }

        /**
         * Remove a file attachment from the current query.
         * Deletes the file from backend and updates local state.
         * 
         * @param {number} fileId - ID of the file to remove
         */
        async function removeQueryFile(fileId) {
            if (!confirm('Are you sure you want to remove this attachment?')) return;
            
            try {
                addLog(`üóëÔ∏è Removing query attachment ID: ${fileId}`, 'info');
                
                const { response, data } = await loggedFetch(`${API_BASE}/files/${fileId}`, {
                    method: 'DELETE'
                }, `DELETE QUERY FILE: ${fileId}`);
                
                if (response.ok) {
                    // Remove from query attached files array
                    queryAttachedFiles = queryAttachedFiles.filter(file => file.id !== fileId);
                    
                    // Remove from UI
                    const filesList = document.getElementById('queryFilesList');
                    const items = filesList.querySelectorAll('li');
                    items.forEach(item => {
                        if (item.innerHTML.includes(`ID: ${fileId}`)) {
                            item.remove();
                        }
                    });
                    
                    addLog(`‚úÖ Query attachment removed: ID ${fileId}`, 'response');
                    
                } else {
                    addLog(`‚ùå Remove attachment error: ${data.detail}`, 'error');
                }
                
            } catch (error) {
                addLog(`‚ùå Remove attachment network error: ${error.message}`, 'error');
            }
        }

        // =============================================================
        // LOGGING AND MONITORING FUNCTIONS
        // =============================================================
        
        /**
         * Add a new log entry to the monitoring console.
         * Provides real-time feedback on API calls and workflow execution.
         * 
         * @param {string} message - Log message to display
         * @param {string} type - Log type for color coding
         * @returns {number} Log entry ID for potential updates
         */
        function addLog(message, type = 'info') {
            const logsContainer = document.getElementById('logsContainer');
            const timestamp = new Date().toLocaleTimeString();
            const logId = ++logCounter;
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.id = `log-${logId}`;
            
            let className = 'log-response';
            switch(type) {
                case 'api': className = 'log-api-call'; break;
                case 'query': className = 'log-query'; break;
                case 'docs': className = 'log-doc-ids'; break;
                case 'error': className = 'log-error'; break;
                case 'response': className = 'log-response'; break;
                case 'workflow-step': className = 'log-workflow-step'; break;
                case 'endpoint': className = 'log-endpoint'; break;
                case 'payload': className = 'log-payload'; break;
                case 'chunk': className = 'log-chunk'; break;
                case 'detailed': className = 'log-detailed'; break;
            }
            
            logEntry.innerHTML = `
                <span class="log-timestamp">[${timestamp}]</span> 
                <span class="${className}">${message}</span>
            `;
            
            logsContainer.appendChild(logEntry);
            logsContainer.scrollTop = logsContainer.scrollHeight;
            return logId;
        }

        /**
         * Update an existing log entry with new information.
         * Used to update status of ongoing operations.
         * 
         * @param {number} logId - ID of log entry to update
         * @param {string} message - New message content
         * @param {string} type - Log type for color coding
         */
        function updateLog(logId, message, type = 'response') {
            const logEntry = document.getElementById(`log-${logId}`);
            if (logEntry) {
                const timestamp = new Date().toLocaleTimeString();
                let className = 'log-response';
                if (type === 'error') className = 'log-error';
                
                logEntry.innerHTML = `
                    <span class="log-timestamp">[${timestamp}]</span> 
                    <span class="${className}">${message}</span>
                `;
            }
        }

        /**
         * Clear all log entries and reset the monitoring console.
         */
        function clearLogs() {
            const logsContainer = document.getElementById('logsContainer');
            logsContainer.innerHTML = `
                <div class="log-entry">
                    <span class="log-timestamp">[Ready]</span> 
                    <span class="log-response">Logs cleared. Waiting for API activity...</span>
                </div>
            `;
            logCounter = 0;
        }

        // =============================================================
        // API INTEGRATION FUNCTIONS
        // =============================================================
        
        /**
         * Enhanced fetch wrapper with comprehensive logging.
         * Logs all API calls, responses, and errors for debugging.
         * 
         * @param {string} url - API endpoint URL
         * @param {object} options - Fetch options (method, headers, body)
         * @param {string} description - Human-readable description of the call
         * @returns {object} Response object with data and status
         */
        async function loggedFetch(url, options = {}, description = '') {
            const logId = addLog(`üåê API CALL: ${description || url}`, 'api');
            
            try {
                // Log request details
                if (options.body) {
                    try {
                        const bodyData = JSON.parse(options.body);
                        if (bodyData.description) {
                            addLog(`üìù WORKFLOW DESC: ${bodyData.description.substring(0, 100)}...`, 'query');
                        }
                        if (bodyData.user_input) {
                            addLog(`üîç USER QUERY: ${bodyData.user_input}`, 'query');
                        }
                    } catch (e) {
                        // Not JSON, skip parsing
                    }
                }
                
                const response = await fetch(url, options);
                const data = await response.json();
                
                // Log response details
                if (response.ok) {
                    updateLog(logId, `‚úÖ ${description || 'API CALL'} - SUCCESS (${response.status})`, 'response');
                    
                    // Log specific response details
                    if (url.includes('/workflows') && !url.includes('/execute')) {
                        addLog(`üîß WORKFLOW ID: ${data.id}`, 'response');
                        if (data.generated_code) {
                            addLog(`üíª CODE GENERATED: ${data.generated_code.length} characters`, 'response');
                        }
                    }
                    
                    if (url.includes('/execute')) {
                        addLog(`‚ö° EXECUTION ID: ${data.execution_id}`, 'response');
                        addLog(`üìä STATUS: ${data.status}`, 'response');
                        if (data.execution_time) {
                            addLog(`‚è±Ô∏è EXECUTION TIME: ${data.execution_time.toFixed(2)}s`, 'response');
                        }
                    }
                } else {
                    updateLog(logId, `‚ùå ${description || 'API CALL'} - ERROR (${response.status})`, 'error');
                    addLog(`üö® ERROR DETAILS: ${data.detail || 'Unknown error'}`, 'error');
                }
                
                return { response, data };
                
            } catch (error) {
                updateLog(logId, `‚ùå ${description || 'API CALL'} - NETWORK ERROR`, 'error');
                addLog(`üö® NETWORK ERROR: ${error.message}`, 'error');
                throw error;
            }
        }

        // =============================================================
        // WORKFLOW MANAGEMENT FUNCTIONS
        // =============================================================
        
        /**
         * Create a new workflow from user description.
         * Calls AI service to generate executable code from natural language.
         */
        async function createWorkflow() {
            const description = document.getElementById('workflowDescription').value.trim();
            const name = document.getElementById('workflowName').value.trim();
            const resultDiv = document.getElementById('workflowResult');
            
            if (!description) {
                showResult(resultDiv, 'Please enter a workflow description', 'error');
                addLog('‚ùå No workflow description provided', 'error');
                return;
            }

            showResult(resultDiv, 'Creating workflow...', 'loading');
            addLog('üöÄ Starting workflow creation...', 'info');

            try {
                const { response, data } = await loggedFetch(`${API_BASE}/workflows`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        description: description,
                        name: name || null
                    })
                }, 'CREATE WORKFLOW');

                if (response.ok) {
                    currentWorkflowId = data.id;
                    document.getElementById('testButton').disabled = false;
                    
                    const resultMessage = `‚úÖ Workflow created successfully!\n\nID: ${data.id}\nName: ${data.name || 'Unnamed'}\nStatus: ${data.status}\n\nGenerated Code:\n${data.generated_code || 'No code generated'}`;
                    
                    showResult(resultDiv, resultMessage, 'success');
                } else {
                    showResult(resultDiv, `‚ùå Error: ${data.detail || 'Failed to create workflow'}`, 'error');
                }
            } catch (error) {
                showResult(resultDiv, `‚ùå Network Error: ${error.message}`, 'error');
            }
        }

        /**
         * Execute a workflow with user query and optional file attachments.
         * Runs the generated workflow code and displays results with detailed logging.
         */
        async function executeWorkflowWithQuery() {
            if (!currentWorkflowId) {
                alert('Please create a workflow first');
                addLog('‚ùå No workflow to execute', 'error');
                return;
            }

            const query = document.getElementById('testQuery').value.trim();
            const resultDiv = document.getElementById('testResult');
            
            if (!query) {
                showResult(resultDiv, 'Please enter a query', 'error');
                addLog('‚ùå No query provided', 'error');
                return;
            }

            // Check if files are attached
            const hasAttachments = queryAttachedFiles.length > 0;
            const attachmentIds = queryAttachedFiles.map(file => file.id);

            showResult(resultDiv, 'Executing workflow... (this may take up to 5 minutes for document analysis)', 'loading');
            addLog('üöÄ Starting workflow execution...', 'info');
            addLog(`üéØ WORKFLOW ID: ${currentWorkflowId}`, 'response');
            addLog(`üìù USER QUERY: ${query}`, 'query');
            
            if (hasAttachments) {
                addLog(`üìé ATTACHED DOCUMENTS: ${attachmentIds.length} files [${attachmentIds.join(', ')}]`, 'docs');
            }

            try {
                // Prepare execution payload with attached files
                let executionPayload = {
                    user_input: query
                };
                
                if (hasAttachments) {
                    executionPayload.attached_file_ids = attachmentIds;
                }

                const { response, data } = await loggedFetch(`${API_BASE}/workflows/${currentWorkflowId}/execute`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(executionPayload)
                }, 'EXECUTE WORKFLOW WITH QUERY');

                if (response.ok) {
                    const executionTime = data.execution_time ? `${data.execution_time.toFixed(2)}s` : 'N/A';
                    
                    addLog(`‚ö° WORKFLOW EXECUTION COMPLETED in ${executionTime}`, 'workflow-step');
                    
                    // Enhanced workflow result parsing
                    if (data.result) {
                        addLog('üìÑ ANALYZING WORKFLOW EXECUTION DETAILS...', 'workflow-step');
                        
                        const result = data.result;
                        
                        // Look for specific workflow steps and log them with details
                        if (result.includes('WORKFLOW STEP: Paradigm Search')) {
                            addLog('üîç STEP DETECTED: Paradigm Document Search executed', 'workflow-step');
                        }
                        
                        if (result.includes('WORKFLOW STEP: Document Analysis')) {
                            addLog('üìä STEP DETECTED: Document Analysis executed', 'workflow-step');
                        }
                        
                        if (result.includes('WORKFLOW STEP: Ask Question About File')) {
                            addLog('‚ùì STEP DETECTED: File Question executed', 'workflow-step');
                        }
                        
                        if (result.includes('WORKFLOW STEP: Chat Completion')) {
                            addLog('üí¨ STEP DETECTED: AI Chat Completion executed', 'workflow-step');
                        }
                        
                        // Extract and log search queries
                        const searchQueries = result.match(/SEARCH QUERY: ([^\n]+)/g);
                        if (searchQueries) {
                            searchQueries.forEach((query, i) => {
                                const queryText = query.replace('SEARCH QUERY: ', '');
                                addLog(`üîç SEARCH QUERY ${i+1}: ${queryText}`, 'query');
                            });
                        }
                        
                        // Extract and log analysis queries
                        const analysisQueries = result.match(/ANALYSIS QUERY: ([^\n]+)/g);
                        if (analysisQueries) {
                            analysisQueries.forEach((query, i) => {
                                const queryText = query.replace('ANALYSIS QUERY: ', '');
                                addLog(`üìä ANALYSIS QUERY ${i+1}: ${queryText}`, 'query');
                            });
                        }
                        
                        // Extract and log file questions
                        const fileQuestions = result.match(/QUESTION: ([^\n]+)/g);
                        if (fileQuestions) {
                            fileQuestions.forEach((question, i) => {
                                const questionText = question.replace('QUESTION: ', '');
                                addLog(`‚ùì FILE QUESTION ${i+1}: ${questionText}`, 'query');
                            });
                        }
                        
                        // Extract and log document IDs
                        const docIdMatches = result.match(/DOCUMENT IDS: ([^\n]+)/g);
                        if (docIdMatches) {
                            docIdMatches.forEach((match, i) => {
                                const docIds = match.replace('DOCUMENT IDS: ', '');
                                addLog(`üìã DOCUMENT IDS USED ${i+1}: ${docIds}`, 'docs');
                            });
                        }
                        
                        // Extract and log file IDs
                        const fileIdMatches = result.match(/FILE ID: (\d+)/g);
                        if (fileIdMatches) {
                            fileIdMatches.forEach((match, i) => {
                                const fileId = match.replace('FILE ID: ', '');
                                addLog(`üìÅ FILE ID PROCESSED ${i+1}: ${fileId}`, 'docs');
                            });
                        }
                        
                        // Extract and log API endpoints
                        const endpointMatches = result.match(/ENDPOINT: ([^\n]+)/g);
                        if (endpointMatches) {
                            endpointMatches.forEach((match, i) => {
                                const endpoint = match.replace('ENDPOINT: ', '');
                                addLog(`üì° API ENDPOINT ${i+1}: ${endpoint}`, 'endpoint');
                            });
                        }
                        
                        // Extract and log response content
                        const responseMatches = result.match(/(SEARCH RESULT|ANALYSIS RESULT|FILE QUESTION RESULT): ([^\n]+)/g);
                        if (responseMatches) {
                            responseMatches.forEach((match, i) => {
                                const [type, content] = match.split(': ');
                                addLog(`üí¨ ${type} ${i+1}: ${content.substring(0, 150)}...`, 'response');
                            });
                        }
                        
                        // Look for error patterns
                        const errorMatches = result.match(/‚ùå ([^\n]+)/g);
                        if (errorMatches) {
                            errorMatches.forEach((match, i) => {
                                const error = match.replace('‚ùå ', '');
                                addLog(`‚ùå ERROR ${i+1}: ${error}`, 'error');
                            });
                        }
                        
                        // Look for attached file processing
                        if (hasAttachments) {
                            addLog(`üìé PROCESSED ${attachmentIds.length} ATTACHED FILE(S): [${attachmentIds.join(', ')}]`, 'docs');
                        }
                    }
                    
                    if (data.status === 'completed') {
                        addLog('‚úÖ WORKFLOW EXECUTION COMPLETED SUCCESSFULLY', 'response');
                        
                        let resultMessage = `‚úÖ Workflow executed successfully!\n\nExecution ID: ${data.execution_id}\nStatus: ${data.status}\nExecution Time: ${executionTime}`;
                        
                        if (hasAttachments) {
                            resultMessage += `\nProcessed ${attachmentIds.length} attached document(s)`;
                        }
                        
                        resultMessage += `\n\n=== RESULT ===\n${data.result}`;
                        
                        showResult(resultDiv, resultMessage, 'success');
                        
                        // Clear attachments after successful execution
                        queryAttachedFiles = [];
                        document.getElementById('queryFilesList').innerHTML = '';
                        document.getElementById('queryUploadStatus').innerHTML = '';
                        
                    } else {
                        addLog(`‚ö†Ô∏è WORKFLOW STATUS: ${data.status}`, 'error');
                        showResult(resultDiv, 
                            `‚ö†Ô∏è Workflow execution status: ${data.status}\n\nExecution ID: ${data.execution_id}\nExecution Time: ${executionTime}\nError: ${data.error || 'Unknown error'}`, 
                            'error'
                        );
                    }
                } else {
                    showResult(resultDiv, `‚ùå Error: ${data.detail || 'Failed to execute workflow'}`, 'error');
                }
            } catch (error) {
                showResult(resultDiv, `‚ùå Network Error: ${error.message}`, 'error');
            }
        }

        /**
         * Display result messages in the UI with appropriate styling.
         * 
         * @param {Element} element - DOM element to display result in
         * @param {string} message - Message to display
         * @param {string} type - Result type (success, error, loading)
         */
        function showResult(element, message, type) {
            element.innerHTML = `<div class="result ${type}">${message}</div>`;
        }


        // =============================================================
        // PAGE INITIALIZATION
        // =============================================================
        
        /**
         * Initialize the page with example workflows and default state.
         */
        window.onload = function() {
            const examples = [
                "Search for documents about the user's question, then analyze those documents to provide a detailed summary.",
                "For each sentence in the user input, search for relevant documents, then format results as Question and Answer pairs.",
                "Search for documents, extract key information using chat completion, then analyze specific documents for deeper insights."
            ];
            
            // You can uncomment this to show examples
            // document.getElementById('workflowDescription').placeholder = examples[0];
            document.getElementById('testButton').textContent = 'Test Workflow';
        };
    </script>
</body>
</html>